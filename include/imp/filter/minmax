#ifndef    IMP_FILTER_MINMAX_HEADER
#   define IMP_FILTER_MINMAX_HEADER

#include <type_traits>
#include <ex/window>
#include <ex/utility>


#include "imp/common/matrix"

//
// O(M*N*r) implementation of 2D Min/Max filter
//
//      M x N - matrix, r - filter radius
//
// Usage:
//
//   1)  auto min_matrix = imp::MinFilter(4).apply(matrix);
//
//   2)  imp::MinFilter(4).apply(ex::in_place, matrix);
//
//
// Note:
//
//   implementation with O(M*N*log(r)) possible, but
//   maintaining queue for log(r) search absorb all
//   time advantage and benefit will appear only
//   on really large radiuses.
//
//

namespace imp
{


namespace internal
{


template <typename T>
const T& get_extremum(const ex::MinWindow<T>& w) { return w.minimum(); }

template <typename T>
const T& get_extremum(const ex::MaxWindow<T>& w) { return w.maximum(); }


template <typename Window, typename M1, typename M2>
void extremum_row_filter(const IDenseObject <M1>& source, IDenseObject<M2>& out, index_t radius)
{
    index_t h = source.rows();
    index_t w = source.cols();

    index_t window_size = 2 * radius + 1;
    index_t initial     = std::min(radius, w-1);

    for (index_t y = 0; y < h; ++y)
    {
        // TODO: fix for case <source> is eigen eXpression
        // TODO: use iterator in Window insted of pointer
        Window sliding_window(window_size, &source.coeff(y, 0), w);

        // fill window
        for (index_t i = 0; i < initial; ++i)
        {
            sliding_window.next();
        }

        // fill result
        for (index_t out_x = 0; out_x < w; ++out_x)
        {
            sliding_window.next();
            out(y, out_x) = get_extremum(sliding_window);
        }
    }
}

template <typename Window, typename M1, typename M2>
void extremum_row_filter(const IDenseObject<M1>& source, IDenseObject<M2>&& out, index_t radius)
{
    // handle eigen expressions (temporary rvalue objects) as lvalue
    extremum_row_filter<Window>(source, out, radius);
}



} // internal


template<bool is_min_filter = true>
class MinMaxFilter final
{
    template<typename T>
    using Window = typename std::conditional<is_min_filter, ex::MinWindow<T>, ex::MaxWindow<T>>::type;

public:
    explicit MinMaxFilter(index_t radius) : m_radius(radius)
    {
    }

public:
    index_t radius() const { return m_radius; }

public:
    template <typename M>
    M apply(const IDenseObject<M>& image)
    {
        using namespace internal;

        using T = typename M::Scalar;

        M tmp(image.cols(), image.rows());
        M result(image.rows(), image.cols());

        extremum_row_filter<Window<T>>(image,  tmp.transpose(), m_radius);
        extremum_row_filter<Window<T>>(tmp, result.transpose(), m_radius);

        return result;
    }


    template <typename M>
    void apply(ex::in_place_t, IDenseObject<M>& image)
    {
        using namespace internal;

        using T = typename M::Scalar;

        M tmp(image.cols(), image.rows());

        extremum_row_filter<Window<T>>(image, tmp.transpose(), m_radius);
        extremum_row_filter<Window<T>>(tmp, image.transpose(), m_radius);
    }


    template <typename M>
    M apply(const IDenseObject<M>&& image)
    {
        // handle eigen eXpressions
        throw std::logic_error("work with eigen eXpressions is not implemented yet");
    }


    template <typename M>
    void apply(ex::in_place_t, IDenseObject<M>&& image)
    {
        // handle eigen eXpressions
        throw std::logic_error("work with eigen eXpressions is not implemented yet");
    }

private:
    index_t m_radius;
};


using MinFilter = MinMaxFilter<true>;

using MaxFilter = MinMaxFilter<false>;


}
#endif // IMP_FILTER_MINMAX_HEADER
