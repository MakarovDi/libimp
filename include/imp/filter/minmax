#ifndef    IMP_FILTER_MINMAX_HEADER
#   define IMP_FILTER_MINMAX_HEADER

#include <type_traits>
#include <ex/utility>
#include <ex/window>
#include <ex/iterator/make>

#include "imp/common/matrix"
#include "imp/common/iterator"


//
// O(M*N*r) implementation of 2D Min/Max filter
//
//      M x N - matrix, r - filter radius
//
// Usage:
//
//   1)  auto min_matrix = imp::MinFilter(4).apply(matrix);
//
//   2)  imp::MinFilter(4).apply(ex::in_place, matrix);
//
//
// Note:
//
//   implementation with O(M*N*log(r)) possible, but
//   maintaining queue for log(r) search absorb all
//   time advantage and benefit will appear only
//   on really large radiuses.
//
//

namespace imp
{


enum MinMaxMode : int
{
    kMinimum = 0,
    kMaximum
};


namespace internal
{

    template <MinMaxMode mode, typename M1, typename M2>
    void extremum_row_filter(const IDenseObject<M1>& source, IDenseObject<M2>& out, index_t radius)
    {
        using Window = typename std::conditional
                       <
                           mode == MinMaxMode::kMinimum,
                           ex::MinWindow<typename M1::Scalar>,
                           ex::MaxWindow<typename M1::Scalar>

                       >::type;

        index_t h = source.rows();
        index_t w = source.cols();

        index_t window_size = 2 * radius + 1;
        index_t initial     = std::min(radius, w-1);

        for (index_t y = 0; y < h; ++y)
        {
            Window sliding_window(window_size, &source(y, 0), source.cols());

            // fill window
            for (index_t i = 0; i < initial; ++i)
            {
                sliding_window.next();
            }

            // fill result
            for (index_t out_x = 0; out_x < w; ++out_x)
            {
                sliding_window.next();
                out(y, out_x) = sliding_window.extremum();
            }
        }
    }

    template <MinMaxMode mode, typename M1, typename M2>
    void extremum_row_filter(const IDenseObject<M1>& source, IDenseObject<M2>&& out, index_t radius)
    {
        // handle eigen expressions (temporary rvalue objects) as lvalue
        extremum_row_filter<mode>(source, out, radius);
    }

} // internal



template<MinMaxMode kMode>
class MinMaxFilter final
{
public:
    explicit MinMaxFilter(index_t radius) : m_radius(radius)
    {
    }

public:
    index_t radius() const { return m_radius; }

public:
    template <typename M>
    M apply(const IDenseObject<M>& image)
    {
        using namespace internal;

        using T = typename M::Scalar;

        M tmp(image.cols(), image.rows());
        M result(image.rows(), image.cols());

        extremum_row_filter<kMode>(image,  tmp.transpose(), m_radius);
        extremum_row_filter<kMode>(tmp, result.transpose(), m_radius);

        return result;
    }


    template <typename M>
    void apply(ex::in_place_t, IDenseObject<M>& image)
    {
        using namespace internal;

        using T = typename M::Scalar;

        M tmp(image.cols(), image.rows());

        extremum_row_filter<kMode>(image, tmp.transpose(), m_radius);
        extremum_row_filter<kMode>(tmp, image.transpose(), m_radius);
    }


    template <typename M>
    M apply(const IDenseObject<M>&& image)
    {
        // handle eigen eXpressions
        throw std::logic_error("work with eigen eXpressions is not implemented yet");
    }


    template <typename M>
    void apply(ex::in_place_t, IDenseObject<M>&& image)
    {
        // handle eigen eXpressions
        throw std::logic_error("work with eigen eXpressions is not implemented yet");
    }

private:
    index_t m_radius;
};


using MinFilter = MinMaxFilter<MinMaxMode::kMinimum>;

using MaxFilter = MinMaxFilter<MinMaxMode::kMaximum>;


}
#endif // IMP_FILTER_MINMAX_HEADER
