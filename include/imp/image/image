#ifndef    IMP_IMAGE_HEADER
#   define IMP_IMAGE_HEADER


#include <ex/common/type>
#include <ex/policy/notice>

#include "imp/common/matrix"


namespace imp
{


template <class T>
struct EmptyFacade;


// TODO: change [class Facade = EmptyFacade<T>] -> [template <class> class Facade = EmptyFacade]
// TODO: when msvc grow up to it. msvc 2015 can't trace it

template
<
    class T,
    class Facade = EmptyFacade<T>
>
class Image final : public Facade
{
    using Matrix = Matrix<T>;
public:
    Image() :
        m_width(0),
        m_height(0),
        m_plane_size(0),
        m_data()
    {
        init_planes();
    }


    Image(index_t width, index_t height) :
        m_width(width),
        m_height(height),
        m_plane_size(width*height),
        m_data(3*m_plane_size, 1)
    {
        init_planes();
    }


    explicit Image(index_t width, index_t height, const T* ptr, RawMemory mem_mode) :
        m_width(width),
        m_height(height),
        m_plane_size(width*height),
        m_data(3*m_plane_size, 1, ptr, mem_mode)
    {
        init_planes();
    }


    template <index_t M, index_t N>
    Image(const T (&ptr)[3][M][N]) :
        Image(N, M, reinterpret_cast<const T*>(ptr), RawMemory::kCopy)
    {
    }

public:
    Image(const Image& image) : Image(image.width(), image.height())
    {
        m_data = image.m_data;
    }


    Image& operator=(const Image& rgb)
    {
        if (this == &rgb) return *this;

        m_plane_size = rgb.m_plane_size;
        m_height = rgb.m_height;
        m_width = rgb.m_width;

        m_data = rgb.m_data;

        init_planes();

        return *this;
    }

public:
    Image(Image&&) noexcept = default;
    Image& operator=(Image&&) noexcept = default;

public:
    bool operator==(const Image& img) const
    {
        if (this == &img) return true;

        if (width() != img.width() || height() != img.height())
            return false;

        if (ptr() == img.ptr())
            return true;

        return m_data == img.m_data;
    }

    bool operator!=(const Image& img) const { return !operator==(img); }

public:
    index_t width()       const { return m_width;  }
    index_t height()      const { return m_height; }

    index_t plane_size()  const { return m_plane_size;         }
    index_t total_size()  const { return m_data.size();        }
    index_t memory_size() const { return m_data.memory_size(); }

    const T* ptr() const { return m_data.ptr(); }
    T*       ptr()       { return m_data.ptr(); }

    bool is_own_memory()  const { return m_data.is_own_memory(); }

public:
    using ColorPlane = typename Facade::ColorPlane;

public:
    const T& color(index_t index,        ColorPlane color_plane) const { return m_plane[color_plane][index];       }
          T& color(index_t index,        ColorPlane color_plane)       { return m_plane[color_plane][index];       }
    const T& color(index_t x, index_t y, ColorPlane color_plane) const { return color(x + y*width(), color_plane); }
          T& color(index_t x, index_t y, ColorPlane color_plane)       { return color(x + y*width(), color_plane); }

    const T& operator()(index_t index,        ColorPlane color_plane) const { return color(index, color_plane); }
          T& operator()(index_t index,        ColorPlane color_plane)       { return color(index, color_plane); }
    const T& operator()(index_t x, index_t y, ColorPlane color_plane) const { return color(x, y, color_plane);  }
          T& operator()(index_t x, index_t y, ColorPlane color_plane)       { return color(x, y, color_plane);  }

    const T& operator()(index_t index) const { return m_data[index]; }
          T& operator()(index_t index)       { return m_data[index]; }
    const T& operator[](index_t index) const { return m_data[index]; }
          T& operator[](index_t index)       { return m_data[index]; }


    const Matrix& plane(index_t plane_index) const
    {
        return m_plane[plane_index];
    }

    Matrix plane(index_t plane_index)
    {
        //
        // create proxy matrix object: without data copy and pointer to plane data
        // to protect internal plane matrix from assigment operator (reallocation case)
        //
        return Matrix(width(), height(), m_plane[plane_index].ptr(), RawMemory::kReuse);
    }

private:
    void init_planes()
    {
        m_plane[0] = Matrix(width(), height(), ptr(),                  RawMemory::kReuse);
        m_plane[1] = Matrix(width(), height(), ptr() +   plane_size(), RawMemory::kReuse);
        m_plane[2] = Matrix(width(), height(), ptr() + 2*plane_size(), RawMemory::kReuse);
    }

private:
    index_t m_width;
    index_t m_height;
    index_t m_plane_size;

    Matrix m_data;
    Matrix m_plane[3];
};



template <class T>
struct EmptyFacade
{
    using Image = Image<T, EmptyFacade>;


    enum ColorPlane : index_t
    {
        kPlane1 = 0,
        kPlane2 = 1,
        kPlane3 = 2,
        kCount,
    };

protected:
    EmptyFacade()  {}
    ~EmptyFacade() {} // non-virtual destructor
};


}

#include "imp/image/operator"


#endif // IMP_IMAGE_HEADER
